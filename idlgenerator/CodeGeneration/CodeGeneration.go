package CodeGeneration

import (
	"fmt"
	si "github.com/bhbosman/CodeGenerators/idlgenerator/ScopingInterfaces"
	"go.uber.org/multierr"
	"io"
	"os"
	"path"
	"strings"
	"unicode"
)


type GolangCodeGenerator struct {
	indent    int
	openFiles map[string]io.WriteCloser
}

func NewGenerateCodeGolang() *GolangCodeGenerator {
	return &GolangCodeGenerator{
		indent:    0,
		openFiles: make(map[string]io.WriteCloser),
	}
}

func (self GolangCodeGenerator) Generate(dcl si.ITypeSpec) error {
	var err error
	for typeSpec := dcl; typeSpec != nil; typeSpec, _ = typeSpec.GetNextTypeSpec() {
		err = multierr.Append(
			err,
			self.internalGenerate(nil, typeSpec))
	}
	return err
}

func (self *GolangCodeGenerator) Close() error {
	var err error = nil
	for _, v := range self.openFiles {
		err = multierr.Append(
			err,
			v.Close())
	}
	return err
}

type NullWriter struct {
}

func (self NullWriter) Write(p []byte) (n int, err error) {
	return len(p), nil
}

func (self GolangCodeGenerator) findWriter(dcl si.ITypeSpec) (io.Writer, error) {

	if dcl.GetFileName() == "(string test)" || dcl.GetFileName() == "(built-in)" {
		return &NullWriter{}, nil
	}
	idlFileName := dcl.GetFileName()
	if writer, ok := self.openFiles[idlFileName]; ok {
		return writer, nil
	}
	goFile := fmt.Sprintf("%v.%v", idlFileName, "go")
	file, err := os.Create(goFile)
	if err != nil {
		return nil, err
	}
	self.writeComment(file, " Code generated by abc. DO NOT EDIT.")
	self.blankLine(file)
	dir, _ := path.Split(idlFileName)
	splitFolders := strings.Split(dir, string(os.PathSeparator))
	self.writeLine(file, false, "package %v", splitFolders[len(splitFolders)-2])
	self.blankLine(file)

	self.openFiles[idlFileName] = file
	return file, nil
}

func (self GolangCodeGenerator) internalGenerate(writer io.Writer, dcl si.ITypeSpec) error {
	switch dcl.GetKind() {
	case si.Attr_specIdlType:
		attributeDecl, ok := dcl.(si.IAttributeDcl)
		if ok {
			newWriter, e := self.findWriter(dcl)
			if e != nil {
			}
			return self.generateAttributeDcl(newWriter, attributeDecl)
		}
		return fmt.Errorf("could not type case to si.IAttributeDcl")
	case si.ExceptionIdlType:
		exceptionDecl, ok := dcl.(si.IIdlException)
		if ok {
			newWriter, e := self.findWriter(dcl)
			if e != nil {
			}
			return self.generateExceptionDcl(newWriter, exceptionDecl)
		}
		return fmt.Errorf("could not type case to si.IIdlException")
	case si.ConstDclType:
		constantDecl, ok := dcl.(si.IIdlConstDcl)
		if ok {
			newWriter, e := self.findWriter(dcl)
			if e != nil {
			}
			return self.generateConstantDcl(newWriter, constantDecl)
		}
		return fmt.Errorf("could not type case to si.IIdlConstDcl")
	case si.ModuleIdlType:
		moduleDcl, ok := dcl.(si.IIdlModuleDcl)
		if ok {
			newWriter, e := self.findWriter(dcl)
			if e != nil {
			}
			return self.generateModuleDcl(newWriter, moduleDcl)
		}
		return fmt.Errorf("could not type case to si.IIdlModuleDcl")
	case si.StructIdlType:
		structType, ok := dcl.(si.IStructType)
		if ok {
			newWriter, e := self.findWriter(dcl)
			if e != nil {
			}
			return self.generateStructDcl(newWriter, structType)
		}
		return fmt.Errorf("could not type case to si.IStructType")
	case si.RWEnumIdlType:
		enumType, ok := dcl.(si.IEnumType)
		if ok {
			newWriter, e := self.findWriter(dcl)
			if e != nil {
			}
			return self.generateEnumDcl(newWriter, enumType)
		}
		return fmt.Errorf("could not type case to si.IEnumType")
	case si.InterfaceIdlType:
		interfaceDcl, ok := dcl.(si.IInterfaceDcl)
		if ok {
			newWriter, e := self.findWriter(dcl)
			if e != nil {
			}
			return self.generateInterfaceDcl(newWriter, interfaceDcl)
		}
		return fmt.Errorf("could not type case to si.IInterfaceDcl")
	case si.Op_dclIdlType:
		operation, ok := dcl.(si.IOperationDeclarations)
		if ok {
			newWriter, e := self.findWriter(dcl)
			if e != nil {

			}
			return self.generateOperationDcl(newWriter, operation)
		}
		return fmt.Errorf("could not type case to si.IOperationDeclarations")
	case si.IdlValue_Abs_DefType:
		value, ok := dcl.(si.IInterfaceDcl)
		if ok {
			newWriter, e := self.findWriter(dcl)
			if e != nil {

			}
			return self.generateInterfaceDcl(newWriter, value)
		}
		return fmt.Errorf("could not type case to si.IInterfaceDcl")
	case si.TypeDeclaratorIdlType:
		typeDecl, ok := dcl.(si.ITypeDeclarator)
		if ok {
			newWriter, e := self.findWriter(typeDecl)
			if e != nil {
			}
			return self.generateTypeDcl(newWriter, typeDecl)
		}
		return fmt.Errorf("could not type case to si.ITypeDeclarator")
	case si.SequenceIdlType:
		typeDecl, ok := dcl.(si.ISequenceType)
		if ok {
			newWriter, e := self.findWriter(typeDecl)
			if e != nil {
			}
			return self.generateSequenceTypeDcl(newWriter, typeDecl)
		}
		return fmt.Errorf("could not type case to si.ISequenceType")
	default:
		return fmt.Errorf("unknown type. Kind: %v", dcl.GetKind())
	}

}

func (self GolangCodeGenerator) writeLineNumber(writer io.Writer, dcl si.ITypeSpec) {
	_, file := path.Split(dcl.GetFileName())
	self.blankLine(writer)
	self.writeComment(writer, "line %v:%v", file, dcl.GetRow())
}

func (self GolangCodeGenerator) generateModuleDcl(writer io.Writer, dcl si.IIdlModuleDcl) error {
	self.writeLineNumber(writer, dcl)
	var err error

	err = multierr.Append(
		err,
		dcl.Iterate(
			func(typeSpec si.ITypeSpec) error {
				return self.internalGenerate(writer, typeSpec)
			}))

	return err
}

func (self GolangCodeGenerator) exportDclName(dcl si.IBaseDeclaredType) string {
	breakUpName := func(input string) string {
		s := strings.Split(input, "::")
		r := make([]string, 0, len(s))
		for _, item := range s {
			r = append(r, self.exportMemberName(item))
		}
		return strings.Join(r, "_")
	}
	switch dcl.GetKind() {
	case si.RWfloatIdlType:
		return "CorbaFloat"
	case si.AnsiStringIdlType:
		return "AnsiString"
	case si.WideStringIdlType:
		return "WideString"
	case si.RWVoidType:
		return "void"
	case si.RWdoubleIdlType:
		return "CorbaDouble"
	case si.RWlongRWdoubleIdlType:
		return "CorbaLongDouble"
	case si.RWshortIdlType:
		return "int16"
	case si.RWlongIdlType:
		return "int32"
	case si.RWint8IdlType:
		return "int8"
	case si.RWlongRWlongIdlType:
		return "int64"
	case si.RWuint8IdlType:
		return "uint8"
	case si.RWunsignedRWshortIdlType:
		return "uint16"
	case si.RWunsignedRWlongIdlType:
		return "uint32"
	case si.RWunsignedRWlongRWlongIdlType:
		return "uint64"
	case si.RWcharIdlType:
		return "AnsiChar"
	case si.RWwcharIdlType:
		return "WideChar"
	case si.RWbooleanIdlType:
		return "bool"
	case si.RWoctetIdlType:
		return "int"
	case si.RWanyIdlType:
		return "CorbaAny"
	case si.RWObjectIdlType:
		return "CorbaObject"
	case si.RWint16IdlType:
		return "int16"
	case si.RWint32IdlType:
		return "int32"
	case si.RWint64IdlType:
		return "int64"
	case si.RWuint16IdlType:
		return "uint16"
	case si.RWuint32IdlType:
		return "uint32"
	case si.RWuint64IdlType:
		return "uint64"
	case si.SequenceIdlType:
		if t, ok := dcl.(si.ISequenceType); ok {
			return self.exportSequenceName(t)
		}
		return "afasdasdas"
	case si.ExceptionIdlType:
		return fmt.Sprintf("%vException", breakUpName(dcl.GetName()))
	default:
		return breakUpName(dcl.GetName())

	}
}

func (self GolangCodeGenerator) exportMemberName(name string) string {
	b := []byte(name)
	b[0] = byte(unicode.ToUpper(rune(name[0])))
	return string(b)
}

func (self GolangCodeGenerator) incomingParamName(name string) string {
	b := []byte(name)
	b[0] = byte(unicode.ToLower(rune(name[0])))
	s := string(b)
	s = self.checkForReservedWord(s)
	return s
}

func (self GolangCodeGenerator) generateEnumDcl(writer io.Writer, dcl si.IEnumType) error {
	self.writeLineNumber(writer, dcl)
	self.writeComment(writer, "Usage Count: %v", dcl.UsageCount())
	self.writeLine(writer, true, "type %v int", self.exportDclName(dcl))
	self.writeLine(writer, true, "const (")
	self.incIndent(writer)
	first := true
	for m := dcl.Enumerator(); m != nil; m = m.Next() {
		if first {
			self.writeLine(writer, true, "%v_%v = iota", self.exportDclName(dcl), m.Id())
		} else {
			self.writeLine(writer, true, "%v_%v", self.exportDclName(dcl), m.Id())
		}

		first = false
	}

	self.decIndent(writer)
	self.writeLine(writer, true, ")")
	return nil
}

func (self GolangCodeGenerator) buildDeclarationName(scope, name string) string {
	if scope == "" {
		return name
	}
	return fmt.Sprintf("%v::%v", scope, name)
}

func (self GolangCodeGenerator) generateInterfaceDcl(writer io.Writer, dcl si.IInterfaceDcl) error {
	doBefore := func(dcl si.ITypeSpec) bool {
		switch dcl.GetKind() {
		case si.StructIdlType, si.ExceptionIdlType, si.TypeDeclaratorIdlType:
			return true
		default:
			return false
		}
	}
	err := dcl.Iterate(
		func(dcl si.ITypeSpec) error {
			if doBefore(dcl) {
				return self.internalGenerate(writer, dcl)
			}
			return nil
		})
	exportName := self.exportDclName(dcl)
	if dcl.Forward() {
		return nil
	}

	self.writeLineNumber(writer, dcl)
	self.writeComment(writer, "Interface Decl: %v", exportName)
	self.writeComment(writer, "Usage Count: %v", dcl.UsageCount())
	self.writeLine(writer, true, "type %v interface {", exportName)
	self.incIndent(writer)
	err = multierr.Append(
		err,
		dcl.Iterate(
			func(dcl si.ITypeSpec) error {
				if !doBefore(dcl) {
					return self.internalGenerate(writer, dcl)
				}
				return nil
			}))
	self.decIndent(writer)
	self.writeLine(writer, true, "}")
	return err
}

func (self GolangCodeGenerator) generateOperationDcl(writer io.Writer, dcl si.IOperationDeclarations) error {
	self.writeLineNumber(writer, dcl)
	self.write(writer, true, "%v(", self.exportMemberName(dcl.GetName()))
	if dcl.GetParams() != nil {
		for param := dcl.GetParams(); param != nil; param = param.GetNextParameterDeclarations() {
			self.write(writer, false, "%v %v", self.incomingParamName(param.GetParamName()), self.exportDclName(param.GetParamDeclarationType()))
			if param.GetNextParameterDeclarations() != nil {
				self.write(writer, false, ",")
			}
		}
	}
	if dcl.GetOperationDeclaratorType().GetKind() == si.RWVoidType {
		self.writeLine(writer, false, ") error")

	} else {
		self.writeLine(writer, false, ") (%v, error)", self.exportDclName(dcl.GetOperationDeclaratorType()))
	}

	return nil
}

func (self GolangCodeGenerator) generateTypeDcl(writer io.Writer, dcl si.ITypeDeclarator) error {
	var err error
	if declType, ok := dcl.TypeSpec().(si.IDeclaredType); ok {
		if declType.IsPrimitive() {
			self.writeLineNumber(writer, dcl)
			self.writeLine(writer, true, "type %v %v", self.exportDclName(dcl), self.exportDclName(dcl.TypeSpec()))
		} else if declType, ok := dcl.TypeSpec().(si.ISequenceType); ok {
			err = multierr.Append(
				err,
				self.internalGenerate(writer, declType))
			self.writeLineNumber(writer, dcl)
			self.writeComment(writer, "Typedef Decl: %v", self.exportDclName(dcl))
			self.writeLine(writer, true, "type %v %v", self.exportDclName(dcl), self.exportSequenceName(declType))
		}
	}

	return err
}

func (self GolangCodeGenerator) generateConstantDcl(writer io.Writer, dcl si.IIdlConstDcl) error {
	self.writeLineNumber(writer, dcl)
	return nil
}

func (self GolangCodeGenerator) generateStructDcl(writer io.Writer, dcl si.IStructType) error {
	return self.generateBaseStructDcl(
		writer,
		dcl,
		fmt.Sprintf("Struct Decl: %v", self.exportDclName(dcl)))
}

func (self GolangCodeGenerator) generateExceptionDcl(writer io.Writer, dcl si.IIdlException) error {
	return self.generateBaseStructDcl(
		writer,
		dcl,
		fmt.Sprintf("Exception Decl: %v", self.exportDclName(dcl)))
}

func (self GolangCodeGenerator) generateAttributeDcl(writer io.Writer, dcl si.IAttributeDcl) error {
	self.writeLineNumber(writer, dcl)
	self.writeLine(writer, true, "Get%v() %v", self.exportMemberName(dcl.GetName()), self.exportDclName(dcl.DeclaredType()))
	if !dcl.ReadOnly() {
		self.writeLine(writer, true, "Set%v(value %v)", self.exportMemberName(dcl.GetName()), self.exportDclName(dcl.DeclaredType()))
	}
	return nil
}

func (self GolangCodeGenerator) generateBaseStructDcl(writer io.Writer, dcl si.IBaseStructType, comment string) error {
	var err error
	exportName := self.exportDclName(dcl)
	var memberList []si.IStructMemberInformation
	if dcl.Members() != nil {
		memberList = dcl.Members().GetMembers()
	}

	members := dcl.Members()
	if members != nil {
		for _, memberInformation := range members.GetMembers() {
			memberInformationTypeSpec := memberInformation.GetTypeSpec()
			switch memberInformationTypeSpec.GetKind() {
			case si.DeclareTypePlaceHolderType:
				break
			case si.SequenceIdlType:
				if declaredType, ok := memberInformationTypeSpec.(si.ITypeSpec); ok {
					err = multierr.Append(
						err,
						self.internalGenerate(writer, declaredType))
				}
				break
			}
		}
	}
	self.writeLineNumber(writer, dcl)
	self.writeComment(writer, comment)
	self.writeComment(writer, "Usage Count: %v", dcl.UsageCount())
	self.writeLine(writer, true, "type %v struct {", exportName)
	if dcl.Members() != nil {
		self.incIndent(writer)
		for _, memberInfo := range memberList {
			self.writeLine(writer, true, "%v %v", self.exportMemberName(memberInfo.GetId()), self.exportDclName(memberInfo.GetTypeSpec()))
		}
		self.decIndent(writer)
	}
	self.writeLine(writer, true, "}")

	self.generateBaseStructDclConstructors(writer, dcl)
	self.writeLine(writer, true, "")
	self.writeComment(writer, "Constructors")
	self.writeLine(writer, true, "func New%vDefaultPointer() (*%v, error) {", exportName, exportName)

	self.incIndent(writer)
	self.write(writer, true, "return &")
	self.writeDefaultValue(writer, dcl, 0)
	self.writeLine(writer, false, ", nil")
	self.decIndent(writer)

	self.writeLine(writer, true, "}")

	self.blankLine(writer)
	self.writeLine(writer, true, "func New%vDefaultValue() (%v, error) {", exportName, exportName)

	self.incIndent(writer)
	self.write(writer, true, "return ")
	self.writeDefaultValue(writer, dcl, 0)
	self.writeLine(writer, false, ", nil")
	self.decIndent(writer)

	self.writeLine(writer, true, "}")

	self.blankLine(writer)

	if dcl.Members() != nil {
		self.writeLine(writer, true, "func New%vValue(", exportName)
		self.incIndent(writer)
		for i, memberInfo := range memberList {
			self.write(writer, true, "%v %v", self.incomingParamName(memberInfo.GetId()), self.exportDclName(memberInfo.GetTypeSpec()))
			if i == len(memberList)-1 {

			} else {
				self.writeLine(writer, false, ",")
			}
		}
		self.writeLine(writer, false, ") (%v, error) {", exportName)
		self.writeLine(writer, true, "return %v {", exportName)
		self.incIndent(writer)
		for _, memberInfo := range memberList {
			self.writeLine(writer, true, "%v: %v,", self.exportMemberName(memberInfo.GetId()), self.incomingParamName(memberInfo.GetId()))
		}
		self.decIndent(writer)
		self.writeLine(writer, true, "}, nil")
		self.decIndent(writer)
		self.writeLine(writer, true, "}")
	}
	return err
}

func (self GolangCodeGenerator) generateBaseStructDclConstructors(writer io.Writer, structType si.IBaseStructType) {

}

func (self GolangCodeGenerator) writeDefaultValue(writer io.Writer, dcl si.IBaseDeclaredType, count int) {
	switch dcl.GetKind() {
	case si.StructIdlType, si.ExceptionIdlType:
		if _, ok := dcl.(si.IBaseStructType); ok {
			exportName := self.exportDclName(dcl)
			self.write(writer, false, "%v {", exportName)
			//if baseStruct.Members() != nil {
			//	memberList := baseStruct.Members().GetMembers()
			//	self.incIndent(writer)
			//	for _, memberInfo := range memberList {
			//		self.write(writer, true, "%v: ", self.exportMemberName(memberInfo.GetId()))
			//		self.writeDefaultValue(writer, memberInfo.GetTypeSpec(), count+1)
			//	}
			//	self.decIndent(writer)
			//}
			self.write(writer, false, "}")
		}
	case si.DeclareTypePlaceHolderType:
		self.write(writer, false, "place holder")
	case si.RWEnumIdlType:
		self.write(writer, false, "%v(0)", self.exportDclName(dcl))
	case si.RWfloatIdlType:
		self.write(writer, false, "0.0")
	case si.AnsiStringIdlType:
		self.write(writer, false, "\"\"")
	case si.WideStringIdlType:
		self.write(writer, false, "\"\"")
	case si.RWVoidType:
		self.write(writer, false, "error")
	case si.RWdoubleIdlType:
		self.write(writer, false, "0.0")
	case si.RWlongRWdoubleIdlType:
		self.write(writer, false, "0")
	case si.RWshortIdlType:
		self.write(writer, false, "0")
	case si.RWlongIdlType:
		self.write(writer, false, "0")
	case si.RWint8IdlType:
		self.write(writer, false, "0")
	case si.RWlongRWlongIdlType:
		self.write(writer, false, "0")
	case si.RWuint8IdlType:
		self.write(writer, false, "0")
	case si.RWunsignedRWshortIdlType:
		self.write(writer, false, "0")
	case si.RWunsignedRWlongIdlType:
		self.write(writer, false, "0")
	case si.RWunsignedRWlongRWlongIdlType:
		self.write(writer, false, "0")
	case si.RWcharIdlType:
		self.write(writer, false, "'0'")
	case si.RWwcharIdlType:
		self.write(writer, false, "'0'")
	case si.RWbooleanIdlType:
		self.write(writer, false, "false")
	case si.RWoctetIdlType:
		self.write(writer, false, "0")
	case si.RWanyIdlType:
		self.write(writer, false, "nil")
	case si.RWObjectIdlType:
		self.write(writer, false, "nil")
	case si.RWint16IdlType:
		self.write(writer, false, "0")
	case si.RWint32IdlType:
		self.write(writer, false, "0")
	case si.RWint64IdlType:
		self.write(writer, false, "0")
	case si.RWuint16IdlType:
		self.write(writer, false, "0")
	case si.RWuint32IdlType:
		self.write(writer, false, "0")
	case si.RWuint64IdlType:
		self.write(writer, false, "0")
	case si.RWvaluebaseIdlType:
		self.write(writer, false, "nil")
	default:
		self.writeLine(writer, false, "need default value for '%v'", dcl.GetKind().String())
	}
	if count == 0 {
		self.write(writer, false, "")
	} else {
		self.writeLine(writer, false, ",")
	}
}

func (self GolangCodeGenerator) writeLine(writer io.Writer, useTabs bool, f string, p ...interface{}) {
	tabs := func(tabs bool) string {
		if tabs {
			return strings.Repeat("\t", self.indent)
		}
		return ""
	}(useTabs)
	s := fmt.Sprintf(f, p...)
	data := fmt.Sprintf("%v%v\n", tabs, s)
	if writer != nil {
		_, _ = writer.Write([]byte(data))
	} else {
		fmt.Printf(data)
	}
}

func (self GolangCodeGenerator) write(writer io.Writer, useTabs bool, f string, p ...interface{}) {
	tabs := func(tabs bool) string {
		if tabs {
			return strings.Repeat("\t", self.indent)
		}
		return ""
	}(useTabs)
	s := fmt.Sprintf(f, p...)
	data := fmt.Sprintf("%v%v", tabs, s)
	if writer != nil {
		_, _ = writer.Write([]byte(data))
	} else {
		fmt.Printf(data)
	}
}

func (self GolangCodeGenerator) writeComment(writer io.Writer, f string, p ...interface{}) {
	tabs := strings.Repeat("\t", self.indent)
	s := fmt.Sprintf(f, p...)
	data := fmt.Sprintf("%v//%v\n", tabs, s)
	if writer != nil {
		_, _ = writer.Write([]byte(data))
	} else {
		fmt.Printf(data)
	}
}

func (self GolangCodeGenerator) blankLine(writer io.Writer) {

	data := fmt.Sprintf("\n")
	if writer != nil {
		_, _ = writer.Write([]byte(data))
	} else {
		fmt.Printf(data)
	}

}

func (self *GolangCodeGenerator) incIndent(writer io.Writer) {
	self.indent++
}

func (self *GolangCodeGenerator) decIndent(writer io.Writer) {
	self.indent--
}

func (self GolangCodeGenerator) checkForReservedWord(s string) string {
	switch s {

	case "break":
		return s + "_"
	case "case":
		return s + "_"
	case "chan":
		return s + "_"
	case "const":
		return s + "_"
	case "continue":
		return s + "_"
	case "default":
		return s + "_"
	case "defer":
		return s + "_"
	case "else":
		return s + "_"
	case "fallthrough":
		return s + "_"
	case "for":
		return s + "_"
	case "func":
		return s + "_"
	case "go":
		return s + "_"
	case "goto":
		return s + "_"
	case "if":
		return s + "_"
	case "import":
		return s + "_"
	case "interface":
		return s + "_"
	case "map":
		return s + "_"
	case "package":
		return s + "_"
	case "range":
		return s + "_"
	case "return":
		return s + "_"
	case "select":
		return s + "_"
	case "struct":
		return s + "_"
	case "switch":
		return s + "_"
	case "type":
		return s + "_"
	case "var":
		return s + "_"
	default:
		return s
	}
}

func (self GolangCodeGenerator) generateSequenceTypeDcl(writer io.Writer, dcl si.ISequenceType) error {
	self.writeLineNumber(writer, dcl)
	self.writeComment(writer, "Sequence Decl: %v", self.exportDclName(dcl))
	self.writeLine(writer, true, "type %v interface{}", self.exportSequenceName(dcl))

	return nil
}

func (self GolangCodeGenerator) exportSequenceName(dcl si.ISequenceType) string {
	return fmt.Sprintf("Sequence_%v", self.exportDclName(dcl.TypeSpec()))
}
