// Generated by golex
package yacc

import (
	"bufio"
	"bytes"
	"io"
	"os"
	"regexp"
	"sort"
)
import "strings"
import "path"

func stripToFileName(s string) string {
	return strings.TrimFunc(
		s,
		func(r rune) bool {
			switch r {
			case '"', '<', '>', '\t', '\n', '\v', '\f', '\r', ' ', 0x85, 0xA0:
				return true
			}
			return false
		})
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
type CurrentStream struct {
	column    int
	row       int
	fileName  string
	yydata    string
	yyorig    string
	yyorigidx int
	yylessed  int

	yytextrepl bool
	prev       *CurrentStream
}

func NewCurrentStream(fileName string, yyin io.Reader) *CurrentStream {
	reader := bufio.NewReader(yyin)
	yydata := ""
	for {
		line, err := reader.ReadString('\n')
		if len(line) == 0 && err == io.EOF {
			break
		}

		yydata += line
	}

	return &CurrentStream{
		column:     1,
		row:        1,
		fileName:   fileName,
		yydata:     yydata,
		yyorig:     yydata,
		yyorigidx:  0,
		prev:       nil,
		yylessed:   0,
		yytextrepl: true,
	}
}

type Tokenizer struct {
	yyout         io.Writer
	userContext   interface{}
	currentStream *CurrentStream

	instanceStream *CurrentStream
	yytext         string
	YY_START       yystartcondition
}

func NewTokenizer(fileName string, yyin io.Reader, ctx interface{}) *Tokenizer {
	return &Tokenizer{
		yyout:          os.Stdout,
		userContext:    ctx,
		currentStream:  nil,
		instanceStream: NewCurrentStream(fileName, yyin),
		yytext:         "",
		YY_START:       INITIAL,
	}
}

func (self *Tokenizer) yymore() {
	self.currentStream.yytextrepl = false
}

func (self *Tokenizer) yyBEGIN(state yystartcondition) {
	self.YY_START = state
}

func (self *Tokenizer) yyECHO() {
	self.yyout.Write([]byte(self.yytext))
}

func (self *Tokenizer) yyREJECT() {
	panic("yyREJECT")
}

func (self *Tokenizer) yyless(n int) {
	self.currentStream.yylessed = len(self.yytext) - n
}

func (self *Tokenizer) unput(c uint8) {
	self.currentStream.yyorig = self.currentStream.yyorig[:self.currentStream.yyorigidx] + string(c) + self.currentStream.yyorig[self.currentStream.yyorigidx:]
	self.currentStream.yydata = self.currentStream.yydata[:len(self.yytext)-self.currentStream.yylessed] + string(c) + self.currentStream.yydata[len(self.yytext)-self.currentStream.yylessed:]
}

func (self *Tokenizer) input() int {
	if len(self.currentStream.yyorig) <= self.currentStream.yyorigidx {
		return EOF
	}
	c := self.currentStream.yyorig[self.currentStream.yyorigidx]
	self.currentStream.yyorig = self.currentStream.yyorig[:self.currentStream.yyorigidx] + self.currentStream.yyorig[self.currentStream.yyorigidx+1:]
	self.currentStream.yydata = self.currentStream.yydata[:len(self.yytext)-self.currentStream.yylessed] + self.currentStream.yydata[len(self.yytext)-self.currentStream.yylessed+1:]
	return int(c)
}

func (self *Tokenizer) PushStream(stream *CurrentStream) {
	stream.prev = self.instanceStream
	self.instanceStream = stream
}
func (self *Tokenizer) PopStream() {
	//if self.instanceStream.prev != nil{
	self.instanceStream = self.instanceStream.prev
	//}

}

func (self *Tokenizer) yylex() int {
	self.instanceStream.yyorig = self.instanceStream.yydata
	self.instanceStream.yyorigidx = 0

	for {
		self.currentStream = self.instanceStream
		if self.currentStream == nil {
			break
		}
		for {
			if len(self.currentStream.yydata) == 0 {
				startCondition, ok := yystartconditionexclmap[self.YY_START]
				if !ok || ok && startCondition.action == nil {
					startCondition, ok = yystartconditionexclmap[DEFAULT]
				}
				if ok && startCondition.action != nil {
					ar := startCondition.action(self, self.userContext)
					switch ar.returnType {
					case yyRT_FALLTHROUGH:
						// Do nothing.
					case yyRT_USER_RETURN:
						return ar.userReturn
					case yyRT_REJECT:
						break
					}
				} else {
					break
				}
				if self.instanceStream == nil {
					break
				}
			}

			self.currentStream = self.instanceStream
			if !(len(self.currentStream.yydata) > 0) {
				break
			}
			matches := yylexMatchList(make([]yylexMatch, 0, 6))
			stateFlags := yystartconditionexclmap[self.YY_START]

			for i, v := range yyrules {
				sol := self.currentStream.yyorigidx == 0 || self.currentStream.yyorig[self.currentStream.yyorigidx-1] == '\n'

				if v.sol && !sol {
					continue
				}

				// Check start conditions.
				ok := false

				// YY_START or '*' must feature in v.startConds
				for _, c := range v.startConds {
					if c == self.YY_START || c == -1 {
						ok = true
						break
					}
				}

				if !stateFlags.exclusive {
					// If v.startConds is empty, this is also acceptable.
					if len(v.startConds) == 0 {
						ok = true
					}
				}

				if !ok {
					continue
				}

				idxs := v.regexp.FindStringIndex(self.currentStream.yydata)
				if idxs != nil && idxs[0] == 0 {
					// Check the trailing userContext, if any.
					checksOk := true
					sortLen := idxs[1]
					advLen := idxs[1]

					if v.trailing != nil {
						tridxs := v.trailing.FindStringIndex(self.currentStream.yydata[idxs[1]:])
						if tridxs == nil || tridxs[0] != 0 {
							checksOk = false
						} else {
							sortLen += tridxs[1]
						}
					}

					if checksOk {
						matches = append(matches, yylexMatch{i, v.action, sortLen, advLen})
					}
				}
			}

			if self.currentStream.yytextrepl {
				self.yytext = ""
			}

			sort.Sort(matches)

		tryMatch:
			if len(matches) == 0 {
				self.yytext += self.currentStream.yydata[:1]
				self.currentStream.yydata = self.currentStream.yydata[1:]
				self.currentStream.yyorigidx += 1

				self.yyout.Write([]byte(self.yytext))
			} else {
				m := matches[0]
				self.yytext += self.currentStream.yydata[:m.advLen]
				self.currentStream.yyorigidx += m.advLen

				self.currentStream.yytextrepl, self.currentStream.yylessed = true, 0
				ar := m.matchFunc(self, self.userContext)

				if ar.returnType != yyRT_REJECT {
					self.currentStream.yydata = self.currentStream.yydata[m.advLen-self.currentStream.yylessed:]
					self.currentStream.yyorigidx -= self.currentStream.yylessed
				}

				switch ar.returnType {
				case yyRT_FALLTHROUGH:
					// Do nothing.
				case yyRT_USER_RETURN:
					return ar.userReturn
				case yyRT_REJECT:
					matches = matches[1:]
					self.yytext = self.yytext[:len(self.yytext)-m.advLen]
					self.currentStream.yyorigidx -= m.advLen
					goto tryMatch
				}
			}
		}
		self.currentStream = nil
	}
	return 0
}

func (self *Tokenizer) filePosCounter() {
	for _, s := range self.yytext {
		if s == 0 {
			continue
		}
		if s == '\n' {
			self.currentStream.column = 0
			self.currentStream.row++
		} else {
			self.currentStream.column++
		}
	}
}

type yyrule struct {
	regexp     *regexp.Regexp
	trailing   *regexp.Regexp
	startConds []yystartcondition
	sol        bool
	action     func(self *Tokenizer, ctx interface{}) yyactionreturn
}

type StartCondition struct {
	exclusive bool
	action    func(*Tokenizer, interface{}) yyactionreturn
}

type yyactionreturn struct {
	userReturn int
	returnType yyactionreturntype
}

type yyactionreturntype int

const (
	yyRT_FALLTHROUGH yyactionreturntype = iota
	yyRT_USER_RETURN
	yyRT_REJECT
)

var EOF int = -1

type yystartcondition int

const DEFAULT yystartcondition = -1
const INITIAL yystartcondition = 0

type yylexMatch struct {
	index     int
	matchFunc func(self *Tokenizer, ctx interface{}) yyactionreturn
	sortLen   int
	advLen    int
}

type yylexMatchList []yylexMatch

func (ml yylexMatchList) Len() int {
	return len(ml)
}

func (ml yylexMatchList) Less(i, j int) bool {
	return ml[i].sortLen > ml[j].sortLen && ml[i].index > ml[j].index
}

func (ml yylexMatchList) Swap(i, j int) {
	ml[i], ml[j] = ml[j], ml[i]
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
const datablock yystartcondition = 1024
const ifdefExpression yystartcondition = 1025
const defineExpression yystartcondition = 1026
const pragmaExpression yystartcondition = 1027

var yystartconditionexclmap = map[yystartcondition]StartCondition{
	pragmaExpression: {
		exclusive: true,
		action:    nil,
	},
	datablock: {
		exclusive: false,
		action:    nil,
	},
	ifdefExpression: {
		exclusive: true,
		action:    nil,
	},
	defineExpression: {
		exclusive: true,
		action:    nil,
	},
	DEFAULT: {
		exclusive: false,
		action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
			defer func() {
				if r := recover(); r != nil {
					if r != "yyREJECT" {
						panic(r)
					}
					yyar.returnType = yyRT_REJECT
				}
			}()
			{
				self.PopStream()
			}
			return yyactionreturn{0, yyRT_FALLTHROUGH}
		},
	},
}
var yyrules []yyrule = []yyrule{{
	regexp:     regexp.MustCompile("[ \\t]*#include[ \\t]*"),
	trailing:   nil,
	startConds: []yystartcondition{INITIAL, datablock},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			dd := bytes.NewBufferString("")
			self.filePosCounter()
			for {
				b := byte(self.input())
				if b == '\n' {
					self.currentStream.row++
					break
				}
				_ = dd.WriteByte(b)
			}
			s := dd.String()
			fileName := stripToFileName(s)
			dir, _ := path.Split(self.currentStream.fileName)
			newFileName := path.Join(dir, fileName)

			file, e := os.Open(newFileName)
			if e != nil {
				self.currentStream.row--
				return yyactionreturn{
					userReturn: ErrorFileNotFound,
					returnType: yyRT_USER_RETURN,
				}
			}
			defer func() {
				_ = file.Close()
			}()
			stream := NewCurrentStream(newFileName, file)
			self.filePosCounter()
			self.PushStream(stream)
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("[ \\t]*#define"),
	trailing:   nil,
	startConds: []yystartcondition{INITIAL, datablock},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			ctx.(*AdditionalInformation).stackState.defineFlag = true
			ctx.(*AdditionalInformation).push(self)
			self.yyBEGIN(defineExpression)
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("[ \\t]*#undefine"),
	trailing:   nil,
	startConds: []yystartcondition{INITIAL, datablock},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			ctx.(*AdditionalInformation).stackState.defineFlag = false
			ctx.(*AdditionalInformation).push(self)
			self.yyBEGIN(defineExpression)
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("([^\\n]*)\\n"),
	trailing:   nil,
	startConds: []yystartcondition{pragmaExpression},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			ctx.(*AdditionalInformation).pop(self)
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				if ctx.(*AdditionalInformation).DefinitionContext != nil {
					ctx.(*AdditionalInformation).DefinitionContext.ParsePragma(strings.TrimSpace(self.yytext))
				}
			}
			self.yytext = ""
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("\\n"),
	trailing:   nil,
	startConds: []yystartcondition{datablock},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("([^\\n]*)\\n"),
	trailing:   nil,
	startConds: []yystartcondition{defineExpression},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			ctx.(*AdditionalInformation).pop(self)
			if ctx.(*AdditionalInformation).DefinitionContext != nil {
				ctx.(*AdditionalInformation).DefinitionContext.ParseDefinition(strings.TrimSpace(self.yytext), ctx.(*AdditionalInformation).stackState.defineFlag)
			}
			self.yytext = ""
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("[ \\t]*#pragma"),
	trailing:   nil,
	startConds: []yystartcondition{INITIAL, datablock},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			ctx.(*AdditionalInformation).push(self)
			self.yyBEGIN(pragmaExpression)
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("[ \\t]*#ifdef"),
	trailing:   nil,
	startConds: []yystartcondition{INITIAL, datablock},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			ctx.(*AdditionalInformation).StartIfDefBlock(self, true)
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("[ \\t]*#ifndef"),
	trailing:   nil,
	startConds: []yystartcondition{INITIAL, datablock},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			ctx.(*AdditionalInformation).StartIfDefBlock(self, false)
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("[ \\t]*#endif"),
	trailing:   nil,
	startConds: []yystartcondition{datablock},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			ctx.(*AdditionalInformation).pop(self)
			if ctx.(*AdditionalInformation).YY_STACK == nil {
				self.yyBEGIN(INITIAL)
			} else {
				self.yyBEGIN(datablock)
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("[ \\t]*#else"),
	trailing:   nil,
	startConds: []yystartcondition{datablock},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			self.yyBEGIN(datablock)
			ctx.(*AdditionalInformation).stackState.ifdefBlock = false
			ctx.(*AdditionalInformation).stackState.expressionValue = !ctx.(*AdditionalInformation).stackState.expressionValue
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("([^\\n]*)\\n"),
	trailing:   nil,
	startConds: []yystartcondition{ifdefExpression},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			self.yyBEGIN(datablock)
			ctx.(*AdditionalInformation).stackState.ifdefBlock = true
			tempValue := true
			if ctx.(*AdditionalInformation).DefinitionContext != nil {
				tempValue = ctx.(*AdditionalInformation).DefinitionContext.ParseExpression(strings.TrimSpace(self.yytext))
			}
			ctx.(*AdditionalInformation).stackState.expressionValue = tempValue == ctx.(*AdditionalInformation).stackState.expressionDirection
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("//[^\\n]*\\n"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("/\\*[^*/]*\\*/"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("[ \\t\\n]+"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("L?'(\\\\[^\\n]|[^\\\\'])+'"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{character_literal, yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("L?\\\"(\\\\[^\\n]|[^\\\\\"])*\\\""),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{string_literal, yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("<"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'<', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile(">"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'>', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("\\{"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'{', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("\\}"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'}', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("\\("),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'(', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("\\)"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{')', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("\\["),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'[', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("\\]"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{']', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("\\+"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'+', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("-"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'-', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("/"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'/', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("\\*"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'*', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("%"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'%', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile(";"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{';', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile(","),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{',', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("&"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'&', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("="),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'=', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile(":"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{':', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("\\|"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{'|', yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("::"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{ScopeOp, yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("<<"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{ShlOp, yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile(">>"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{ShrOp, yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("0[xX][0-9A-Fa-f]+"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{Hex_literal, yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("[1-9][0-9]*"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{integer_literal, yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("0"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				return yyactionreturn{integer_literal, yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}, {
	regexp:     regexp.MustCompile("[A-Za-z_][A-Za-z_0-9]*"),
	trailing:   nil,
	startConds: []yystartcondition{datablock, INITIAL},
	sol:        false,
	action: func(self *Tokenizer, ctx interface{}) (yyar yyactionreturn) {
		defer func() {
			if r := recover(); r != nil {
				if r != "yyREJECT" {
					panic(r)
				}
				yyar.returnType = yyRT_REJECT
			}
		}()
		{
			self.filePosCounter()
			returnResult := ((self.YY_START == datablock) && ctx.(*AdditionalInformation).stackState.expressionValue) || (self.YY_START == INITIAL)
			if returnResult {
				if v, ok := ctx.(*AdditionalInformation).reservedWords[self.yytext]; ok {
					return yyactionreturn{v, yyRT_USER_RETURN}
				}
				return yyactionreturn{identifier, yyRT_USER_RETURN}
			}
		}
		return yyactionreturn{0, yyRT_FALLTHROUGH}
	}}}
