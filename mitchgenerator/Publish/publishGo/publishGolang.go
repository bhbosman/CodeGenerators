package publishGo

import (
	"bufio"
	"fmt"
	"github.com/bhbosman/CodeGenerators/mitchgenerator/Publish"

	"github.com/bhbosman/CodeGenerators/mitchgenerator/yacc"
	"go.uber.org/multierr"
)

type publishGolang struct {
}

func (self *publishGolang) Export(params Publish.ExportParams) error {
	var result error = nil
	sb := bufio.NewWriter(params.OutputStream)

	_, _ = sb.WriteString(fmt.Sprintf("// Code generated by goyacc -o idl.go -p IdlExpr idl.y. DO NOT EDIT.\n"))
	_, _ = sb.WriteString(fmt.Sprintf("\n"))
	_, _ = sb.WriteString(fmt.Sprintf("package %v\n", params.PackageName))
	_, _ = sb.WriteString(fmt.Sprintf("import \"fmt\"\n"))
	_, _ = sb.WriteString(fmt.Sprintf("import \"time\"\n"))
	_, _ = sb.WriteString(fmt.Sprintf("import \"github.com/bhbosman/Application/Streams\"\n"))
	_, _ = sb.WriteString(fmt.Sprintf("\n"))
	_, _ = sb.WriteString(fmt.Sprintf("// SetDeclared typed\n"))
	for _, declaredType := range params.DeclaredTypes {
		switch v := declaredType.(type) {
		case *yacc.MitchMessageDefinition:
			if v.HasMessageInformation() {
				_, _ = sb.WriteString(fmt.Sprintf("// %s MessageType: 0x%x(%v)\n", v.Identifier, v.MessageType, v.MessageType))
			}
			break
		default:
			_, _ = sb.WriteString(fmt.Sprintf("// %v\n", declaredType.GetName()))
			break
		}
	}

	_, _ = sb.WriteString(fmt.Sprintf("// \n"))
	for _, declaredType := range params.DeclaredTypes {
		declaredType.GetName()
		if declaredType.Predefined() {
			publish := NewPublishPredefined(declaredType)
			publish.Export(sb)
			continue
		}

		if definition, ok := declaredType.(*yacc.MitchMessageDefinition); ok {
			publish := NewPublishStruct(definition)
			err := publish.Export(sb)
			if err != nil {
				result = multierr.Append(result, err)
			}
			continue
		}

		if definition, ok := declaredType.(*yacc.EnumDecl); ok {
			publish := NewPublishEnum(definition)
			publish.Export(sb)
			continue
		}

		if typeDeclarator, ok := declaredType.(*yacc.TypeDeclarator); ok {
			publish := NewpublishTypeDecl(typeDeclarator)
			publish.Export(sb)
			continue
		}
	}

	_, _ = sb.WriteString(fmt.Sprintf("type CreateAndReadDataNotFound struct {\n"))
	_, _ = sb.WriteString(fmt.Sprintf("\tMessageType int\n"))
	_, _ = sb.WriteString(fmt.Sprintf("}\n"))

	_, _ = sb.WriteString(fmt.Sprintf("func (self *CreateAndReadDataNotFound) Error() string {\n"))
	_, _ = sb.WriteString(fmt.Sprintf("\treturn fmt.Sprintf(\"Could not find message type %%v\", self.MessageType)\n"))
	_, _ = sb.WriteString(fmt.Sprintf("}\n"))

	_, _ = sb.WriteString(fmt.Sprintf("func CreateAndReadData(messageType int, length uint16, stream Streams.IMitchReader) (interface{}, int, error){\n"))

	_, _ = sb.WriteString(fmt.Sprintf("\tswitch messageType {\n"))
	for _, declaredType := range params.DeclaredTypes {
		if definition, ok := declaredType.(*yacc.MitchMessageDefinition); ok {
			if definition.HasMessageInformation() {
				_, _ = sb.WriteString(fmt.Sprintf("\tcase %s_MessageType:\n", definition.Identifier))
				_, _ = sb.WriteString(fmt.Sprintf("\t\tmessage, err := %vFactory.New()\n", definition.Identifier))
				_, _ = sb.WriteString(fmt.Sprintf("\t\tif err != nil {\n"))
				_, _ = sb.WriteString(fmt.Sprintf("\t\t\treturn nil, 0, err\n"))
				_, _ = sb.WriteString(fmt.Sprintf("\t\t}\n"))
				_, _ = sb.WriteString(fmt.Sprintf("\t\tn, err := %vFactory.ReadMessageData(message, stream)\n", definition.Identifier))
				_, _ = sb.WriteString(fmt.Sprintf("\t\tif err != nil {\n"))
				_, _ = sb.WriteString(fmt.Sprintf("\t\t\treturn nil, 0, err\n"))
				_, _ = sb.WriteString(fmt.Sprintf("\t\t}\n"))
				_, _ = sb.WriteString(fmt.Sprintf("\t\treturn message, n, nil\n"))
				_, _ = sb.WriteString(fmt.Sprintf("\t\tbreak\n"))
				_, _ = sb.WriteString(fmt.Sprintf("\n"))
			}
		}
	}
	_, _ = sb.WriteString(fmt.Sprintf("\t}\n"))

	_, _ = sb.WriteString(fmt.Sprintf("\treturn nil, 0, &CreateAndReadDataNotFound{MessageType: messageType,}\n"))
	_, _ = sb.WriteString(fmt.Sprintf("}\n"))

	_, _ = sb.WriteString(fmt.Sprintf("// All Message types\n"))
	_, _ = sb.WriteString(fmt.Sprintf("func AllMessageTypes() []int{\n"))
	_, _ = sb.WriteString(fmt.Sprintf("\treturn []int{\n"))
	for _, declaredType := range params.DeclaredTypes {
		switch v := declaredType.(type) {
		case *yacc.MitchMessageDefinition:
			if v.HasMessageInformation() {
				_, _ = sb.WriteString(fmt.Sprintf("\t\t%s_MessageType,\n", v.Identifier))
			}
			break
		default:

			break
		}
	}
	_, _ = sb.WriteString(fmt.Sprintf("\t}\n"))
	_, _ = sb.WriteString(fmt.Sprintf("}\n"))
	_ = sb.Flush()

	return result
}

func newPublishGolang() *publishGolang {
	return &publishGolang{}
}

func init() {
	Publish.Register(Publish.Go, newPublishGolang())
}
